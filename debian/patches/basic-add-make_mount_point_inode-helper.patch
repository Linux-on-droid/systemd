From: Luca Boccassi <bluca@debian.org>
Date: Sat, 19 Dec 2020 21:40:47 +0000
Subject: basic: add make_mount_point_inode helper

Creates a file or a directory depending on the source path, useful
for creating mount points.

(cherry picked from commit 8bab8029105e44ce78c5e11bffa203a1135fe201)
---
 src/basic/mountpoint-util.c     | 25 +++++++++++++++++++++
 src/basic/mountpoint-util.h     |  4 ++++
 src/core/namespace.c            | 26 +++++++--------------
 src/machine/machine-dbus.c      | 14 ++++--------
 src/test/test-mountpoint-util.c | 50 +++++++++++++++++++++++++++++++++++++++++
 5 files changed, 91 insertions(+), 28 deletions(-)

diff --git a/src/basic/mountpoint-util.c b/src/basic/mountpoint-util.c
index a6602ad..ed7457f 100644
--- a/src/basic/mountpoint-util.c
+++ b/src/basic/mountpoint-util.c
@@ -8,14 +8,17 @@
 #include "fd-util.h"
 #include "fileio.h"
 #include "fs-util.h"
+#include "label.h"
 #include "missing_stat.h"
 #include "missing_syscall.h"
+#include "mkdir.h"
 #include "mountpoint-util.h"
 #include "parse-util.h"
 #include "path-util.h"
 #include "stat-util.h"
 #include "stdio-util.h"
 #include "strv.h"
+#include "user-util.h"
 
 /* This is the original MAX_HANDLE_SZ definition from the kernel, when the API was introduced. We use that in place of
  * any more currently defined value to future-proof things: if the size is increased in the API headers, and our code
@@ -509,3 +512,25 @@ int mount_propagation_flags_from_string(const char *name, unsigned long *ret) {
                 return -EINVAL;
         return 0;
 }
+
+int make_mount_point_inode_from_stat(const struct stat *st, const char *dest, mode_t mode) {
+        assert(st);
+        assert(dest);
+
+        if (S_ISDIR(st->st_mode))
+                return mkdir_label(dest, mode);
+        else
+                return mknod(dest, S_IFREG|(mode & ~0111), 0);
+}
+
+int make_mount_point_inode_from_path(const char *source, const char *dest, mode_t mode) {
+        struct stat st;
+
+        assert(source);
+        assert(dest);
+
+        if (stat(source, &st) < 0)
+                return -errno;
+
+        return make_mount_point_inode_from_stat(&st, dest, mode);
+}
diff --git a/src/basic/mountpoint-util.h b/src/basic/mountpoint-util.h
index aadb212..cebcec5 100644
--- a/src/basic/mountpoint-util.h
+++ b/src/basic/mountpoint-util.h
@@ -23,3 +23,7 @@ int dev_is_devtmpfs(void);
 
 const char *mount_propagation_flags_to_string(unsigned long flags);
 int mount_propagation_flags_from_string(const char *name, unsigned long *ret);
+
+/* Creates a mount point (not parents) based on the source path or stat - ie, a file or a directory */
+int make_mount_point_inode_from_stat(const struct stat *st, const char *dest, mode_t mode);
+int make_mount_point_inode_from_path(const char *source, const char *dest, mode_t mode);
diff --git a/src/core/namespace.c b/src/core/namespace.c
index cdf427a..02381da 100644
--- a/src/core/namespace.c
+++ b/src/core/namespace.c
@@ -1176,29 +1176,19 @@ static int apply_mount(
                 bool try_again = false;
 
                 if (r == -ENOENT && make) {
-                        struct stat st;
+                        int q;
 
                         /* Hmm, either the source or the destination are missing. Let's see if we can create
                            the destination, then try again. */
 
-                        if (stat(what, &st) < 0)
-                                log_error_errno(errno, "Mount point source '%s' is not accessible: %m", what);
-                        else {
-                                int q;
+                        (void) mkdir_parents(mount_entry_path(m), 0755);
 
-                                (void) mkdir_parents(mount_entry_path(m), 0755);
-
-                                if (S_ISDIR(st.st_mode))
-                                        q = mkdir(mount_entry_path(m), 0755) < 0 ? -errno : 0;
-                                else
-                                        q = touch(mount_entry_path(m));
-
-                                if (q < 0)
-                                        log_error_errno(q, "Failed to create destination mount point node '%s': %m",
-                                                        mount_entry_path(m));
-                                else
-                                        try_again = true;
-                        }
+                        q = make_mount_point_inode_from_path(what, mount_entry_path(m), 0755);
+                        if (q < 0)
+                                log_error_errno(q, "Failed to create destination mount point node '%s': %m",
+                                                mount_entry_path(m));
+                        else
+                                try_again = true;
                 }
 
                 if (try_again)
diff --git a/src/machine/machine-dbus.c b/src/machine/machine-dbus.c
index bb67beb..1105008 100644
--- a/src/machine/machine-dbus.c
+++ b/src/machine/machine-dbus.c
@@ -32,6 +32,7 @@
 #include "missing_capability.h"
 #include "mkdir.h"
 #include "mount-util.h"
+#include "mountpoint-util.h"
 #include "namespace-util.h"
 #include "os-util.h"
 #include "path-util.h"
@@ -908,10 +909,7 @@ int bus_machine_method_bind_mount(sd_bus_message *message, void *userdata, sd_bu
 
         /* Second, we mount the source file or directory to a directory inside of our MS_SLAVE playground. */
         mount_tmp = strjoina(mount_slave, "/mount");
-        if (S_ISDIR(st.st_mode))
-                r = mkdir_errno_wrapper(mount_tmp, 0700);
-        else
-                r = touch(mount_tmp);
+        r = make_mount_point_inode_from_stat(&st, mount_tmp, 0700);
         if (r < 0) {
                 sd_bus_error_set_errnof(error, r, "Failed to create temporary mount point %s: %m", mount_tmp);
                 goto finish;
@@ -1003,12 +1001,8 @@ int bus_machine_method_bind_mount(sd_bus_message *message, void *userdata, sd_bu
                 }
 
                 if (make_file_or_directory) {
-                        if (S_ISDIR(st.st_mode))
-                                (void) mkdir_p(dest, 0755);
-                        else {
-                                (void) mkdir_parents(dest, 0755);
-                                (void) mknod(dest, S_IFREG|0600, 0);
-                        }
+                        (void) mkdir_parents(dest, 0755);
+                        (void) make_mount_point_inode_from_stat(&st, dest, 0700);
                 }
 
                 mount_inside = strjoina("/run/host/incoming/", basename(mount_outside));
diff --git a/src/test/test-mountpoint-util.c b/src/test/test-mountpoint-util.c
index 47fde5c..1ce3d5d 100644
--- a/src/test/test-mountpoint-util.c
+++ b/src/test/test-mountpoint-util.c
@@ -8,13 +8,16 @@
 #include "def.h"
 #include "fd-util.h"
 #include "fileio.h"
+#include "fs-util.h"
 #include "hashmap.h"
 #include "log.h"
+#include "mkdir.h"
 #include "mountpoint-util.h"
 #include "path-util.h"
 #include "rm-rf.h"
 #include "string-util.h"
 #include "tests.h"
+#include "tmpfile-util.h"
 
 static void test_mount_propagation_flags(const char *name, int ret, unsigned long expected) {
         long unsigned flags;
@@ -287,6 +290,52 @@ static void test_fd_is_mount_point(void) {
         assert_se(IN_SET(fd_is_mount_point(fd, "root/", 0), -ENOENT, 0));
 }
 
+static void test_make_mount_point_inode(void) {
+        _cleanup_(rm_rf_physical_and_freep) char *d = NULL;
+        const char *src_file, *src_dir, *dst_file, *dst_dir;
+        struct stat st;
+
+        log_info("/* %s */", __func__);
+
+        assert_se(mkdtemp_malloc(NULL, &d) >= 0);
+
+        src_file = strjoina(d, "/src/file");
+        src_dir = strjoina(d, "/src/dir");
+        dst_file = strjoina(d, "/dst/file");
+        dst_dir = strjoina(d, "/dst/dir");
+
+        assert_se(mkdir_p(src_dir, 0755) >= 0);
+        assert_se(mkdir_parents(dst_file, 0755) >= 0);
+        assert_se(touch(src_file) >= 0);
+
+        assert_se(make_mount_point_inode_from_path(src_file, dst_file, 0755) >= 0);
+        assert_se(make_mount_point_inode_from_path(src_dir, dst_dir, 0755) >= 0);
+
+        assert_se(stat(dst_dir, &st) == 0);
+        assert_se(S_ISDIR(st.st_mode));
+        assert_se(stat(dst_file, &st) == 0);
+        assert_se(S_ISREG(st.st_mode));
+        assert_se(!(S_IXUSR & st.st_mode));
+        assert_se(!(S_IXGRP & st.st_mode));
+        assert_se(!(S_IXOTH & st.st_mode));
+
+        assert_se(unlink(dst_file) == 0);
+        assert_se(rmdir(dst_dir) == 0);
+
+        assert_se(stat(src_file, &st) == 0);
+        assert_se(make_mount_point_inode_from_stat(&st, dst_file, 0755) >= 0);
+        assert_se(stat(src_dir, &st) == 0);
+        assert_se(make_mount_point_inode_from_stat(&st, dst_dir, 0755) >= 0);
+
+        assert_se(stat(dst_dir, &st) == 0);
+        assert_se(S_ISDIR(st.st_mode));
+        assert_se(stat(dst_file, &st) == 0);
+        assert_se(S_ISREG(st.st_mode));
+        assert_se(!(S_IXUSR & st.st_mode));
+        assert_se(!(S_IXGRP & st.st_mode));
+        assert_se(!(S_IXOTH & st.st_mode));
+}
+
 int main(int argc, char *argv[]) {
         test_setup_logging(LOG_DEBUG);
 
@@ -311,6 +360,7 @@ int main(int argc, char *argv[]) {
         test_mnt_id();
         test_path_is_mount_point();
         test_fd_is_mount_point();
+        test_make_mount_point_inode();
 
         return 0;
 }
