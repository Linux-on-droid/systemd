From: =?utf-8?q?Antoine_Beaupr=C3=A9?= <anarcat@debian.org>
Date: Sun, 10 Mar 2019 15:04:40 +0100
Subject: backport read_line() from systemd master

CVE-2018-15686 requires a refactoring of fgets() to use the internal
read_line() instead, which is not present in v232.
---
 src/basic/def.h    |  2 ++
 src/basic/fileio.c | 94 +++++++++++++++++++++++++++++++++++++++++++++---------
 src/basic/fileio.h |  2 ++
 3 files changed, 83 insertions(+), 15 deletions(-)

diff --git a/src/basic/def.h b/src/basic/def.h
index 2266eff..756ed91 100644
--- a/src/basic/def.h
+++ b/src/basic/def.h
@@ -88,3 +88,5 @@
         "/usr/local/lib/" n "\0" \
         "/usr/lib/" n "\0" \
         _CONF_PATHS_SPLIT_USR(n)
+
+#define LONG_LINE_MAX (1U*1024U*1024U)
diff --git a/src/basic/fileio.c b/src/basic/fileio.c
index 1615456..0652959 100644
--- a/src/basic/fileio.c
+++ b/src/basic/fileio.c
@@ -27,6 +27,8 @@
 #include <sys/stat.h>
 #include <sys/types.h>
 #include <unistd.h>
+#include <stdio.h>
+#include <stdio_ext.h>
 
 #include "alloc-util.h"
 #include "ctype.h"
@@ -47,6 +49,7 @@
 #include "time-util.h"
 #include "umask-util.h"
 #include "utf8.h"
+#include "def.h"
 
 #define READ_FULL_BYTES_MAX (4U*1024U*1024U)
 
@@ -154,7 +157,7 @@ fail:
 
 int read_one_line_file(const char *fn, char **line) {
         _cleanup_fclose_ FILE *f = NULL;
-        char t[LINE_MAX], *c;
+        int r;
 
         assert(fn);
         assert(line);
@@ -162,22 +165,11 @@ int read_one_line_file(const char *fn, char **line) {
         f = fopen(fn, "re");
         if (!f)
                 return -errno;
+        (void) __fsetlocking(f, FSETLOCKING_BYCALLER);
 
-        if (!fgets(t, sizeof(t), f)) {
-
-                if (ferror(f))
-                        return errno > 0 ? -errno : -EIO;
-
-                t[0] = 0;
-        }
-
-        c = strdup(t);
-        if (!c)
-                return -ENOMEM;
-        truncate_nl(c);
+        r = read_line(f, LONG_LINE_MAX, line);
 
-        *line = c;
-        return 0;
+        return r < 0 ? r : 0;
 }
 
 int verify_file(const char *fn, const char *blob, bool accept_extra_nl) {
@@ -1409,3 +1401,75 @@ int read_nul_string(FILE *f, char **ret) {
 
         return 0;
 }
+
+DEFINE_TRIVIAL_CLEANUP_FUNC(FILE*, funlockfile);
+
+int read_line(FILE *f, size_t limit, char **ret) {
+        _cleanup_free_ char *buffer = NULL;
+        size_t n = 0, allocated = 0, count = 0;
+
+        assert(f);
+
+        /* Something like a bounded version of getline().
+         *
+         * Considers EOF, \n and \0 end of line delimiters, and does not include these delimiters in the string
+         * returned.
+         *
+         * Returns the number of bytes read from the files (i.e. including delimiters â€” this hence usually differs from
+         * the number of characters in the returned string). When EOF is hit, 0 is returned.
+         *
+         * The input parameter limit is the maximum numbers of characters in the returned string, i.e. excluding
+         * delimiters. If the limit is hit we fail and return -ENOBUFS.
+         *
+         * If a line shall be skipped ret may be initialized as NULL. */
+
+        if (ret) {
+                if (!GREEDY_REALLOC(buffer, allocated, 1))
+                        return -ENOMEM;
+        }
+
+        {
+                _unused_ _cleanup_(funlockfilep) FILE *flocked = f;
+                flockfile(f);
+
+                for (;;) {
+                        int c;
+
+                        if (n >= limit)
+                                return -ENOBUFS;
+
+                        errno = 0;
+                        c = fgetc_unlocked(f);
+                        if (c == EOF) {
+                                /* if we read an error, and have no data to return, then propagate the error */
+                                if (ferror_unlocked(f) && n == 0)
+                                        return errno > 0 ? -errno : -EIO;
+
+                                break;
+                        }
+
+                        count++;
+
+                        if (IN_SET(c, '\n', 0)) /* Reached a delimiter */
+                                break;
+
+                        if (ret) {
+                                if (!GREEDY_REALLOC(buffer, allocated, n + 2))
+                                        return -ENOMEM;
+
+                                buffer[n] = (char) c;
+                        }
+
+                        n++;
+                }
+        }
+
+        if (ret) {
+                buffer[n] = 0;
+
+                *ret = buffer;
+                buffer = NULL;
+        }
+
+        return (int) count;
+}
diff --git a/src/basic/fileio.h b/src/basic/fileio.h
index b58c83e..336491f 100644
--- a/src/basic/fileio.h
+++ b/src/basic/fileio.h
@@ -82,6 +82,8 @@ int read_timestamp_file(const char *fn, usec_t *ret);
 
 int fputs_with_space(FILE *f, const char *s, const char *separator, bool *space);
 
+int read_line(FILE *f, size_t limit, char **ret);
+
 int open_tmpfile_unlinkable(const char *directory, int flags);
 int open_tmpfile_linkable(const char *target, int flags, char **ret_path);
 
